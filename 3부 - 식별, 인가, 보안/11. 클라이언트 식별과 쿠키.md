# 11. 클라이언트 식별과 쿠키

## 11.1 개별 접촉

웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있습니다.

* 개별 인사 - 사용자에게 특화된 환영 인사
* 사용자 맞춤 추천 - 고객 맞춤 제품 추천
* 저장된 사용자 정보 - 복잡한 주소나 신용카드 정보를 데이터베이스에 저장
* 세션 추적 - 사용자와 사이트가 상호작용할 수 있도록 상태를 남기기

이 장에서는 HTTP가 사용자를 식별하는 데 사용하는 기술들을 정리합니다.

1. 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
2. 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
3. 사용자 로그인 인증을 통한 사용자 식별
4. URL에 식별자를 포함하는 기술인 fat URL
5. 식별 정보를 지속해서 유지하는 쿠키

## 11.2 HTTP 헤더

* From 헤더 - 사용자의 이메일 주소를 포함합니다. 악의적인 서버가 주소를 모아 스팸메일을 보내는 경우가 많아 From 헤더를 보내는 브라우저가 많지는 않습니다. 주로 크롤러가 데이터 수집시 자신에 대한 정보를 식별할 수 있도록 하는데 사용됩니다.
* User-Agent 헤더 - 사용자가 사용하고 있는 브라우저의 이름과 정보, 혹은 운영체제애 대한 정보도 포함합니다.

```
User-Agent: <product> / <product-version> <comment>

// 크롬
Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36

// 사파리
Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1
```

## 11.3 클라이언트 IP 주소

사용자 식별에 클라이언트 IP 주소를 사용할 수 있습니다. 하지만, 다음과 같은 문제점 때문에 이를 사용하지 않습니다.

* 클라이언트 IP 주소는 사용자가 아니라 사용자의 컴퓨터를 지칭합니다. 여러 사람이 동일한 컴퓨터를 사용하면 각각의 사용자를 구분할 수 없습니다.
* 많은 인터넷 서비스 제공자(ISP)들은 사용자가 로그인시 동적으로 IP 주소를 할당합니다. 로그인 시간에 따라 사용자는 매번 다른 주소를 받으므로 웹 서버는 클라이언트 IP 주소로 사용자를 식별할 수 없습니다.
* 많은 사용자가 보안을 강화하고, 부족한 주소를 관리하기 위해 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 통해 인터넷을 사용합니다. 이 NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기어 클라이언트 IP 주소로 사용자를 식별하기 어렵습니다.
* HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 합니다. 그래서 웹 서버는 클라이언트 IP 주소 대신 프락시 서버의 IP 주소를 바라봅니다. 이런 경우에는 클라이언트 IP 주소로 사용자를 식별할 수 없습니다.

## 11.4 사용자 로그인

웹 서버는 사용자에게 사용자 이름과 비밀번호를 요구하여 명시적으로 식별을 요청할 수 있습니다. 로그인을 수월하게 만들기 위해 HTTP는 `WWW-Authenticate`, `Authorization` 헤더를 이용하여 로그인을 진행하는 자체적인 체계를 가지고 있습니다. 브라우저는 사용자가 로그인이 필요한 서비스에 접근할 경우, 로그인 대화상자를 보여주고, 로그인 수행시 다음 요청부터 `Authorization` 헤더에 그 정보를 기술하여 보냅니다.

<img width="615" alt="스크린샷 2019-03-24 오후 6 28 21" src="https://user-images.githubusercontent.com/13018877/54877465-a09e4800-4e62-11e9-84ff-f1074d9697a3.png">

1. 브라우저는 www.joes-hardware.com 사이트로 요청을 보냅니다.
2. 사이트는 사용자의 식별정보를 알지 못 하므로, `401 Login Required` 응답 코드와 `WWW-Authenticate` 헤더를 반환하여 로그인을 요청합니다.
3. 사용자가 사용자 이름과 비밀번호를 입력하고, 브라우저는 기존 요청을 다시 보냅니다.
4. 이 요청이 성공적으로 처리되면, 브라우저는 서버로부터 사용자 식별 정보를 요청 받으면 자동으로 사용자 이름과 비밀번호를 포함하여 서버로 요청을 전달합니다.(이 때 요청마다 사용자의 식별정보 토큰을 Authorization 헤더에 담아서 전송)

## 11.5 뚱뚱한 URL

어떤 웹 사이트들은 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였습니다.

```html
<a href="/exec/obidos/tg/browse/-/229220/ref=gr_gifts/002-1145265-8016838">All
Gifts</a>
<a href="/exec/obidos/wishlist/ref=gr_pl1_/002-1145265- 8016838">Wish List</a>
<a href="http://s1.amazon.com/exec/varzea/tg/armed-forces/- //ref=gr_af_/002-1145265-
8016838">Salute Our Troops</a>
<a href="/exec/obidos/tg/browse/-/749188/ref=gr_p4_/002- 1145265-8016838">Free
Shipping</a>
<a href="/exec/obidos/tg/browse/-/468532/ref=gr_returns/002- 1145265-8016838">Easy
  Returns</a>
```

* 사용자가 웹 사이트를 처음 방문하면 유일한 ID가 생성되고, 이는 URL에 추가(위의 경우 `002-1145265-8016838`와 같은 형태)되어 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킵니다. 
* 뚱뚱한 URL은 아래와 같은 몇 가지 문제점이 있습니다.

    1.  못생긴 URL - 브라우저에 보이는 뚱뚱한 URL은 새로운 사용자에게 혼란을 줄 수 있습니다.
    1.  공유하지 못 하는 URL - 뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함하기 때문에, 다른 사람과 해당 URL을 공유할 경우 개인정보가 유출될 수 있습니다.
    1.  캐시 사용 불가 - URL이 계속 변경되므로 URL을 통한 캐시가 불가능합니다.
    1. 서버 부하 가중 - 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 합니다.
    1. 이탈 - 사용자는 서비스를 사용하는 동안 사전에 세션 정보가 추가된 링크만 사용해야 뚱뚱한 URL이 올바르게 동작합니다. 세션 정보가 없는 링크를 사용하게 되면, 의도치 않게 URL 세션에서 이탈하기 쉽습니다.
    1. 세션 간 지속성 부재 - 사용자가 뚱뚱한 URL을 북마킹하지 않는 이상 로그아웃시 모든 정보를 사라집니다.

## 11.6 쿠키

* 쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용되는 방식입니다.
* 쿠키만으로 하기 힘든 것들은 앞서서 설명한 기술들과 함께 사용하여 쿠키를 다방면에서 활용합니다.
* 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용을 캐시하지 않습니다.

### 11.6.1 쿠키의 타입

* 세션 쿠키 - 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키입니다. 세션 쿠키는 사용자가 브라우저를 닫으면 삭제됩니다.
* 지속 쿠키 - 지속 쿠키는 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작해도 남아 있는 쿠키입니다. 지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용합니다.
* 세션 쿠키와 지속 쿠키의 유일한 차이점은 **파기 시점**뿐입니다.

### 11.6.2 쿠키는 어떻게 동작하는가

1. 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해 아는 것이 없습니다.
2. 웹 서버는 사용자가 다음번 접속시 해당 사용자를 식별하기 위해 응답으로 쿠키를 할당합니다. 이 때, 쿠키는 `이름=값` 형태의 리스트 형태이고, `Set-Cookie`라는 HTTP 응답 헤더에 기술됩니다. 쿠키는 어떠한 정보도 포함할 수 있습니다.

```
Set-cookie: id="34294"; domain="Joes-hardware.com"
```

브라우저는 `Set-Cookie` 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장합니다. 

3. 사용자가 미래에 동일한 사이트 방문시 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 기술하여 전송합니다.

<img width="617" alt="스크린샷 2019-03-27 오전 12 27 07" src="https://user-images.githubusercontent.com/13018877/55010155-13582080-5027-11e9-910a-8a38d9c8ddf2.png">

### 11.6.3 쿠키 상자 - 클라이언트 측 상태

브라우저는 쿠키 정보를 저장할 책임이 있는데 이 시스템을 **클라이언트 측 상태**라고 합니다. 쿠키 명세에서 이것의 공식적인 이름은 **HTTP 상태 관리 체계(HTTP State Management Mechanism)** 입니다.

#### 구글 크롬 쿠키

* 브라우저는 각기 다른 방식으로 쿠키를 저장합니다.

<img width="1485" alt="스크린샷 2019-03-27 오전 12 45 41" src="https://user-images.githubusercontent.com/13018877/55011876-e5281000-5029-11e9-8a12-d3ef2c2a7d2a.png">

* Name - 쿠키의 이름
* Value - 쿠키의 값
* Path - 쿠키와 관련된 도메인에 있는 경로
* Expires - 쿠키의 파기 시점을 알려주는 값, `Jan 1, 1970 00:00:00 GMT`로부터 파기될 시간을 초 단위로 기술
* Secure - SSL 커넥션에서만 해당 쿠키를 보낼지 판단

#### 사파리 쿠키
<img width="1516" alt="스크린샷 2019-03-27 오전 12 46 27" src="https://user-images.githubusercontent.com/13018877/55011875-e5281000-5029-11e9-9f85-6e6def5938bf.png">

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 보통 각 사이트에 두 개 혹은 세 개의 쿠키만 보냅니다.

* 쿠키를 모두 전달할 경우 성능이 크게 저하됩니다.(콘텐츠의 바이트보다 더 큰 쿠키를 전달할 우려가 있음)
* 쿠키의 대부분은 서버에 특화된 이름/값 쌍을 포함하여, 대부분의 사이트에서는 인식하지 못 하는 무의미한 값입니다.
* 특정 사이트에서 제공하는 정보를 신뢰하지 않는 사이트에서 가져갈 수 있기 때문에 모든 웹 서버에 쿠키를 전달하는 것은 잠재적인 개인정보 문제를 일으킬 수 있습니다.

<img width="608" alt="스크린샷 2019-03-27 오후 11 50 07" src="https://user-images.githubusercontent.com/13018877/55086248-65fb1080-50eb-11e9-94a1-e7c4aaed2452.png">

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달합니다. 이 특징의 대표적인 예외는 웹 서버 업체가 광고 업체와 계약하여 쿠키를 활용하는 경우입니다. 많은 광고는 웹 사이트의 일부인 것처럼 제작되어 지속 쿠키를 생성합니다. 즉, 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 지속 쿠키를 광고사 서버로 전송합니다. 이러한 지속 쿠키와 Referer 헤더를 접목하면 광고사는 사용자의 웹 사용 습관에 대한 방대한 데이터 베이스를 구축할 수 있습니다.

#### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 `Set-Cookie` 응답 헤더에 Domain 속성을 기술하여 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있습니다.

```
Set-Cookie: user="mary17"; domain="airtravelbargains.com"
```

#### 쿠키 Path 속성

Path 속성을 활용하면 웹 사이트의 일부에만 쿠키를 적용할 수 있습니다.

```
Set-Cookie: pref=compact; domain="airtravelbargains.com"; path=/autos/

http://www. airtravelbargains.com/speical.html
Response - Cookie: user="mary17"

http://www. airtravelbargains.com/autos/index.html
Response - Cookie: user="mary17", Cookie: pref=compact
```

### 11.6.5 쿠키 구성요소

현재 사용되는 쿠키 명세는 Version 0 쿠키가 있습니다.(Version 1 쿠키는 deprecated)

### 11.6.6 Version 0(넷스케이프) 쿠키

최초의 쿠키 명세는 넷스케이프가 정의하였고, 이 Version 0 쿠키는 `Set-Cookie` 응답 헤더와 `Cookie` 요청 헤더에 쿠키 조작에 필요한 필드들을 정의하였습니다.

#### Version 0 Set-Cookie 응답 헤더

* `이름=값` - 필수 속성으로 이름과 값 모두 큰따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열입니다. 어떤 `이름=값` 조합이든 만들 수 있습니다.

```
Set-Cookie: customer=Mary
```


* Expires - 쿠키의 생명주기를 가리키는 날짜 문자열을 기술 합니다.(`요일, DD-MM-YY HH:MM:SS GMT` 형태)

```
Set-Cookie: customer=Mary; expires=Wednesday, 09-Nov-99 23:12:40 GMT
```

* Domain - 이 속성에 기술된 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송합니다. `. com`, `.kr`과 같은 형식으로 작성하는 것을 방지하기 위해, 최소 두 개에서 세 개 영역을 가지는 도메인을 기술해야 합니다.

```
Set-Cookie: customer=Mary; domain="joes-hardware.com"
```

* Path - 서버의 특정 문서에만 쿠키를 할당할 수 있도록 해줍니다.

```
Set-Cookie: customer=Mary; domain="joes-hardware.com" path=/autos/
```

* Secure - 이 속성이 포함되어 있으면 쿠키는 SSL 보안 연결을 사용할 때만 쿠키를 전송합니다.

```
Set-Cookie: customer=Mary; secure
```

#### Version 0 Cookie 요청 헤더

클라이언트가 서버에 요청을 보낼 때는 Domain, Path, Secure 필터가 맞으면서, 현재 파기되지 않은 쿠키들을 함께 보냅니다.

```
Cookie: session-id=002-114321; session-id-time=1007884800
```

### 11.6.7 Version 1(RFC 2965) 쿠키

deprecated 되어 생략

