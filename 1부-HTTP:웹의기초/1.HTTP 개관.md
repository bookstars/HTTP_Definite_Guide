# HTTP 개관

-   HTTP(HyperText Transfer Protocol)는 현대 인터넷의 공요어로 전 세계의 웹브라우저, 서버, 웹 애플리케이션은 모두 HTTP를 통해 대화합니다.

-   이번 장에서는 다음에 대해 알아보겠습니다.
    -   리소스(웹 콘텐츠)가 어디서 오는지
    -   웹 트랜잭션이 어떻게 동작하는지
    -   HTTP 통신을 위해 사용하는 메시지의 형식
    -   HTTP 기저의 TCP 네트워크 전송
    -   여러 종류의 HTTP 프로토콜

## 1.1 HTTP: 인터넷의 멀티미디어 배달부

### HTTP

-   HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에, 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장합니다.

-   이러한 특성 덕분에 개발자는 인터넷의 결함이나 약점에 대한 걱정 없이 애플리케이션 고유의 기능을 구현하는데 집중할 수 있습니다.

## 1.2 웹 클라이언트와 서버

![그림 1-1](https://csj4032.github.io/assets/images/books/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%95%B4%ED%82%B9_%EB%B3%B4%EC%95%88/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%BC%EB%B0%98/HTTP%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/figure_1-1.png)

-   위 그림과 같이 **웹 클라이언트**는 **웹 서버**에게 HTTP 요청을 보내고 **웹 서버**는 요청된 데이터를 HTTP 응답으로 돌려 줍니다.

-   HTTP 클라이언트와 HTTP서버는 월드 와이드 웹(www)의 기본 요소 입니다.

## 1.3 리소스

-   웹 서버는 **웹 리소스**를 관리하고 제공하고, **웹 리소스**는 웹 콘텐츠의 원천입니다.

-   가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 콘텐츠 입니다.

    -   정적 콘텐츠
        -   텍스트 파일
        -   HTML 파일
        -   마이크로소프트 워드 파일
        -   어도비 아크로뱃 파일
        -   JPEG 이미지 파일 등

-   리소스는 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수도 있습니다.

    -   동적 콘텐츠
        -   웹 브라우저 위에서 동작하는 JavaScript
        -   카메라에서 라이브 영상을 가져와 보여주기
        -   주식 거래
        -   부동산 데이터베이스 검색 등

-   어떤 종류의 콘텐츠도 리소스가 될 수 있습니다.

### 1.3.1 미디어 타입

-   HTTP는 웹에서 전송되는 객체 각각에 신중하게 **MIME** 타입이라는 데이터 포맷이라는 라벨을 붙입니다.

#### MIME(Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)

-   **MIME** 타입은 사선(/)으로 구분된 주 타입(Primary obect type)과 부 타입(specific subtype)으로 이루어진 문자열 라벨입니다.
    -   HTML로 작성된 텍스트 문서 -> text/html
    -   plain ASCII 텍스트 문서 -> text/plain
    -   JPEG 이미지 -> image/jpeg

### 1.3.2 URI

-   서버 리소스 이름은 **통합 자원 식별자(uniform resource identifier)**, 혹은 **URI**로 불립니다.

-   웹 서버 리소스는 각자 이름을 갖고 있기 때문에, 클라이언트는 이 이름을 통해 관심 있는 리소스를 지목 할 수 있습니다.

-   **URI**에는 **URL**과 **URN**이 있습니다.

### 1.3.3 URL

- **통합 자원 지시자(uniform resource locator, URL)** 는 리소스 식별자의 가장 흔한 형태입니다.

![URL](https://user-images.githubusercontent.com/13018877/50088724-2a78bc80-0247-11e9-9f59-69c1177207cf.png)

<!-- 2장 참조 -->
- URL의 자세한 내용은 2장에서 다루겠습니다.

-   대부분의 URL은 세부분으로 이루어진 표준 포맷을 따릅니다.
    -   URL의 첫 번째 부분은 **스킴(scheme)** 이라고 합니다. 스킴은 리소스에 접근하기 위해 사용되는 프로토콜을 서술합니다.(ex, http://)
    -   두번째 부분은 서버의 인터넷 주소를 제공합니다. (ex, www.naver.com)
    -   마지막은 웹 서버의 리소스를 가르킵니다. (ex, /specials/saw-blade.gif)

### 1.3.4 URN

-   URN은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 합니다.

## 1.4 트랜잭션

-   HTTP 트랜잭션은 **요청 명령(클라이언트에서 서버로 보내는)**과 **응답 결과(서버가 클라이언트에게 돌려주는)**로 구성되어 있습니다. (정형화된 데이터 덩어리)

![그림 1-5](https://image.slidesharecdn.com/httpdefinitiveguidech1-160307075113/95/http-1-8-638.jpg?cb=1457337112)

### 1.4.1 메서드

-   HTTP는 **HTTP 메서드**라고 불리는 여러 가지 종류의 요청 명령을 지원합니다. ~~모든 HTTP 요청 메세지는 한 개의 메서드를 갖는다.~~ -> HTTP 2.0 부터는 멀티파트 데이터를 지원하여 여러개의 요청을 할 수 있습니다.

| HTTP 메서드 | 설명                                                                 |
| ----------- | -------------------------------------------------------------------- |
| GET         | 서버에서 클라이언트로 지정한 리소스를 보내라.                        |
| PUT         | 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소르로 저장하라. |
| DELETE      | 지정한 리소스를 서버에서 삭제하라.                                   |
| POST        | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라.         |
| HEAD        | 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라.              |

<!-- 3장 링크 -->

-   HTTP 메서드에 대해서는 3장에서 상세히 다룰 예정 입니다.

### 1.4.2 상태코드

-   **상태코드**는 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세 자리 숫자입니다.

| HTTP 상태 코드 | 설명                                           |
| -------------- | ---------------------------------------------- |
| 200            | 좋다. 문서가 바르게 반환되었다.                |
| 302            | 다시 보내라. 다른 곳에 가서 리소스를 가져가라. |
| 404            | 없음. 리소스를 찾을 수 없다.                   |

-   HTTP는 각 숫자 상태 코드에 텍스트로 된 "사유 구절(reason phrase)"도 함께 보냅니다.

### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있습니다.

-   '웹 페이지'는 보통 하나의 리소스가 아닌 리소스의 모음입니다.

## 1.5 메세지

-   HTTP 메시지는 단순한 줄 단위의 문자열입니다.(이진 형식이 아닌 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽습니다.)

![그림 1-7](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS5CA3N5zw8dbvXy5yKQ1-BtaqCktvEGqb0MbxWZGcZeLOq5kRyjQ)

-   시작줄
    -   메세지의 첫 줄
    -   요청: 무엇을 해야 하는지
    -   응답: 무슨 일이 일어났는지
-   헤더
    -   각 헤더 필드는 쉬운 구문분석을 위해 쌍점(:)으로 구분
-   본문
    -   어떤 종류의 데이터든 들어갈 수 있습니다.(이진 데이터도 포함 가능)
    -   요청: 웹 서버로 데이터를 실어 보냄
    -   응답: 클라이언트로 데이터를 봔환

## 1.6 TCP 커넥션(Transmission Control Protocol, 전송 제어 프로토콜)

### 1.6.1 TCP/IP

#### TCP

-   **TCP** HTTP가 사용하고 있는 대중적이고 신뢰성 있는 인터넷 전송 프로토콜 입니다.

-   다음과 같은 기능을 제공합니다.
    -   오류 없는 데이터 전송
        <!-- TODO. 순서를 보장해 주는지 -->
    -   순서에 맞는 전달 (데이터는 언제나 보낸 순서대로 도착한다.)
    -   조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다.)

#### TCP/IP

-   **TCP/IP**는 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합입니다.

-   각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해줍니다.

-   일단 **TCP 커넥션**이 맺어지면, 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상된거, 순서가 뒤바뀌어 수신되는 일은 결코 없습니다.

![그림 1-9](https://csj4032.github.io/assets/images/books/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%95%B4%ED%82%B9_%EB%B3%B4%EC%95%88/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%BC%EB%B0%98/HTTP%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/figure_1-9.png)

### 1.6.2 접속, IP 주소 그리고 포트번호

-   HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜(Internet protocol, IP) **주소**와 **포트번호**를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 합니다.

-   HTML 리소스를 사용자에게 보여주는 순서는 다음과 같습니다.
    1. 웹브라우저는 서버의 URL에서 호스트 명을 추출합니다.
    2. 웹브라우저는 서버의 호스트 명을 IP로 변환합니다.
    3. 웹브라우저는 URL에서 포트번호(있다면)를 추출합니다.(default 80)
    4. 웹브라우저는 웹 서버와 TCP 커넥션을 맺습니다.
    5. 웹브라우저는 서버에 HTTP 요청을 보냅니다.
    6. 서버는 웹브라우저에 HTTP 응답을 돌려줍니다.
    7. 커넥션이 닫히면, 웹브라우저는 문서를 보여줍니다.

## 1.8 웹의 구성요소

-   프락시 : 클라이언트와 서버 사이에 위치한 HTTP 중개자
-   캐시 : 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
-   게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹 서버
-   터널 : 단순히 HTTP 통신을 전달하기만 하는 특별환 프락시
-   에이전트 : 자동화된 HTTP 요청을 만드는 준지능적(semi-intelligent) 웹클라이언트

### 1.8.1 프락시

![그림 1-11](https://csj4032.github.io/assets/images/books/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%95%B4%ED%82%B9_%EB%B3%B4%EC%95%88/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%BC%EB%B0%98/HTTP%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/figure_11-1.png)

-   **프락시**는 클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달합니다.(대게 요청을 수정한 뒤에)

-   **프락시**는 주로 보안을 위해 사용됩니다. 즉, 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 합니다.(요청과 응답을 필터링 합니다.)

### 1.8.2 캐시

-   **웹 캐시**와 **캐시 프락시**는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, 특별한 종류의 HTTP 프락시 서버입니다.

-   캐시가 된 문서들은 클라이언트가 같은 문서를 요청하면 그 캐시가 갖고 있는 사본을 받을 수 있습니다.(속도, 데이터 면에서 이득)

<!-- 7장 링크 -->

-   HTTP는, 캐시를 효율적으로 동작하게 하고 캐시된 콘텐츠를 최신버전으로 유지하면서 동시에 프라이버스도 보호하기 위한 많은 기능을 정의 합니다. (자세한 내용은 7장에서 다룰 예정 입니다.)

### 1.8.3 게이트웨이

-   **게이트웨이**는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됩니다.

-   예로, **HTTP/FTP 게이트웨이**는 FTP URI에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옵니다.

<!-- 8장 링크 -->

-   이는 8장에서 더 자세히 다룰 예정 입니다.

### 1.8.4 터널

-   **터널**은 두 커넥션 사이에서 날(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션입니다.

-   예로, 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있습니다.

### 1.8.5 에이전트

-   **사용자 에이전트(혹은 그냥 에이전트)**는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램입니다.

-   예로, Chorm과 같은 인터넷 브라우저가 있고, 우리가 사용하는 모바일도 하나의 에이전트 입니다.
