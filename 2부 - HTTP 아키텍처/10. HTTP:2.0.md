# HTTP/2.0

* HTTP/2.0은 HTTP의 성능 문제를 개선하기 위한 것으로서 계속 업데이트 되고 있는 중입니다.

## 10.1 HTTP/2.0의 등장배경

* HTTP/1.1의 메시지 포맷이 구현의 단순성과 접근성에 주안점을 두고 최적화되다 보니 성능이 어느정도 희생되었습니다.

* 커넥션 하나를 통해 요청을 보내고 그에 대해 응답 하나만을 받는 HTTP의 교환 방식은 단순하지만, 응답을 받아야만 그 다음 요청을 보낼 수 있어서 심각한 **회전 지연이 야기** 되었습니다.

* 이러한 문제 회피를 위해 병렬 커넥션과 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책이 되지 못하였습니다. (4장 참조)

* 2009년 구글은 웹을 더 빠르게 하겠다는 목표 하에 헤더를 압축하여 대역폭을 절약하고, 하나의 TCP 요청에 여러 요청을 동시에 보내며, 서버가 능동적으로 리소스를 푸시하는 기능을 갖춘 'SPDY' 프로토콜을 내놓았습니다.

* HTTP/2.0은 이러한 SPDY프로토콜을 기반으로 작성 진행 중 입니다.

## 10.2 개요

* HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작합니다 .

* HTTP/2.0 요청과 응답은 길이가 정의된 (최대 16838바이트) 한 개 이상의 **프레임** 에 담깁니다.

* HTTP/2.0 메시지 헤더는 압축되어 담겨집니다. HTTP/1.1에서는 무거운 헤더 구조로 인한 문제가 존재하였습니다. (특히 Cookie)

* 프레임들에 담긴 요청과 응답은 **스트림** 을 통해 보내집니다.

* 하나의 스트림이 한 쌍의 요청과 응답을 처리하고, 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어 질 수 있습니다.

* HTTP/2.0은 스트림에 대한 흐름 제어와 우선순위 부여 기능을 제공합니다.

* HTTP/2.0은 서버가 클라이언트의 요청을 명시적으로 받지 않더라도 능동적으로 리소스를 클라이언트에게 푸시하여 보내줄 수 있습니다.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

* HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송됩니다. 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16838바이트 크기의 페이로드가 옵니다.

* 기존의 HTTP/1.1은 플레인 텍스트로 구성되어 있었지만, HTTP/2.0에서는 데이터를 전송할 때, 바이너리로 인코딩하여 전송하게 되었습니다.

* 이렇게 바이너리 포맷의 데이터를 사용하게 되어 이전에는 하나로 모여있던 데이터를 **프레임** 이라는 단위로 나눠서 관리 / 전송할 수 있게 되었습니다.

<img width="600" src="https://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F214EB844593A20AA15596A">

### 10.3.2 스트림과 멀티플렉싱

* 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스입니다.

* HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있기 때문에 여러 개의 요청이 동시에 보내질 수 있습니다.

* 스트림에 우선순위 부여가 가능합니다. 그러나 우선순위에 따르는 것이 의무사항은 아니므로 요청이 우선순위대로 처리된다는 보장은 없습니다.

* 모든 스트림은 고유한 식별자를 갖습니다.

* 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만듭니다. 이는 스트림을 만들 때 협상을 위해 TCP패킷을 주고받는 낭비를 줄입니다.

* 한번 사용한 스트림 식별자는 다시 사용할 수 없으며, 식별자가 고갈되면 다시 커넥션을 맺으면 됩니다.

### 10.3.3 헤더 압축

* HTTP/1.1에서는 헤더가 아무런 압축 없이 그대로 전송되었습니다.

* 웹페이지 방문에 따른 요청이 증가할수록 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었습니다.

* HTTP/2.0에서는 HPACK 명세에 정의된 헤더 압축 방법으로 헤더를 압축한 뒤 헤더 블록 조각들로 쪼개져서 전송됩니다.

* 받는 쪽에서는 블록 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원합니다.

### 10.3.4 서버 푸시

* HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해줍니다.

* 이는 클라이언트가 HTML 문서를 파싱해서 필요한 리소르를 다시 요청하여 발생하게 되는 트래픽과 회전 지연을 줄여줍니다.

* 리소스를 푸시하려는 서버는 자원을 푸시할 것임을 알리는 PUSH_PROMISE 프레임을 보내어 미리 알려줍니다.

* 클라이언트가 PUSH_PROMISE 프레임을 받으면 해당 스트림은 예약 상태가 됩니다.

* 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할수도 있습니다. 이 경우, 그 스트림은 즉각 닫히게 됩니다.

* 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려는 리소스를 요청해서는 안됩니다.

* PUSH_PROMISE 프레임을 보내는 이유는 서버가 푸시하려는 자원을 클라이언트가 별도로 또 요청하게 되는 상황을 피하기 위함입니다.

* 서버 푸시의 주의점은 다음과 같습니다.

  * 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수도 있고, 서버로부터 받지 않아도 클라이언트에게 추가 리소스를 전달할수도 있습니다.

  * 서버는 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있습니다.

  * 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 합니다 .

  * PUSH_PROMISE 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내집니다.

  * 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 합니다.

  * 푸시 서버를 끄고 싶다면, SETTINGS_ENABLE_PUSH를 0으로 설정하면 됩니다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

* HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있습니다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

* 클라이언트와 서버사이의 커넥션이 오래 유지될 수 있음에 따라 개인 정보 유출에 악용될 가능성이 있습니다. 
