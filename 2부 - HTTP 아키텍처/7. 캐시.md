# 캐시

* 웹 캐시란 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치입니다.

* 이번 장에서는 다음에 대해 알아봅니다.

  * 어떻게 캐시가 성능을 개선하고 비용을 줄이는지

    1. 불필요한 데이터 전송을 줄여서 네트워크 요금 비용을 줄여줍니다.

    2. 네트워크 병목을 줄여줍니다.

    3. 원 서버에 대한 요청을 감소시켜 서버 부하를 줄여줍니다.

    4. 거리로 인한 지연을 줄여줍니다.

  * 어떻게 그 효과를 측정하는지

  * 그 효과를 극대화하기 위해서 캐시를 어디에 위치시켜야 하는지

  * 어떻게 HTTP가 캐시된 최신의 사본을 유지하는지

  * 어떻게 캐시가 다른 캐시나 서버와 상호작용하는지

## 7.1 캐시의 혜택 - 불필요한 데이터 전송

* 똑같은 바이트들이 네트워크를 통해 반복 이동되는 것은 값비싼 네트워크 대역폭을 잡아먹고 전송을 느리게 하며 웹 서버에 부하를 줍니다.

* 캐시를 이용하면, 첫 번째 서버 응답이 캐시에 보관되고 뒤이은 같은 요청들에 대한 응답으로 사용되므로 트래픽 낭비가 줄어듭니다.

## 7.2 캐시의 혜택 - 대역폭 병목

* 캐시는 네트워크 병목을 줄여줍니다.

* 대다수의 네트워크가 원격 서버보다 로컬네트워크 클라이언트에 더 넓은 대역폭을 제공합니다.

* 따라서 클라이언트가 원격 서버가 아닌, 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 큰 문서일수록 성능을 대폭 개선할 수 있습니다.

## 7.3 캐시의 혜택 - 갑작스런 요청 쇄도 (Flash Crowds)

* 갑작스럽게 초래된 트래픽 급증은 네트워크와 웹 서버에 심각한 장애를 야기시킵니다.

* 캐시는 이러한 갑작스런 요청 쇄도에 의한 웹 서버 과부화를 줄여줍니다.

## 7.4 캐시의 혜택 - 거리로 인한 지연

* 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시키며, 빛의 속도 그 자체 역시 지연을 유발합니다.

* 따라서 클라이언트 근처의 캐시를 이용하여 거리로 인한 지연을 줄일 수 있습니다.

## 7.5 적중과 부적중

* 캐시는 매우 유용하지만 캐시가 모든 문서의 사본을 저장하지는 않습니다.

* 캐시에 요청이 도착했을 때, 그에 해당하는 사본이 있어서 요청이 처리되는 것을 **캐시 적중(cache hit)** 이라고 부릅니다.

* 해당 사본이 없어서 원 서버로 전달되는 것을 **캐시 부적중(cache miss)** 이라고 부릅니다.


### 7.5.1 재검사

* 원 서버 콘텐츠는 언제든지 변경될 수 있으므로, 캐시는 반드시 가지고 있는 사본이 최신인지 점검해야 합니다. (HTTP 재검사)

* 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냅니다. 재검사 요청 도구로 주로 If-Modified-Since 헤더 도구가 자주 사용됩니다.

* If-Modified-Since가 GET요청에 있을 경우, 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 됩니다.

```
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
```

* 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보냅니다.

```
HTTP/1.0 304 Not Modified
Date: Wed, 03 Jul 2002, 19:18:03 GMT
Content-type: text/plain
Content-length: 67
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```

* 이를 **캐시 재검사 적중(Cache revalidate hit)** 이라고 부릅니다. 성공적인 재검사는 캐시 적중보다는 느리고 부적중보다는 빠릅니다.  


<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/73ff58bc1817fed7fcb75e2542a345fe/7.1.png">

* 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냅니다.

* 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제합니다.

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/126cd6938c018afeeae3558618bd0323/7.2.png">


### 7.5.2 적중률

* 캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부릅니다.

* 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여주므로, 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어듭니다.

### 7.5.3 바이트 적중률

* 문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않습니다.

* 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현합니다.

* 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여주므로, 바이트 단위 적중률 개선은 대역폭 절약을 최적화합니다.

### 7.5.4 적중과 부적중의 구별

* HTTP는 클라이언트에게 응답이 캐시 적중이었는지 원서버 접근이었는지 말해주지 않습니다.

* 특정 상용 프락시 캐시는 Via 헤더에 추가 정보를 붙이기도 합니다.

* Date 헤더 값을 현재 시각과 비교하여 응답이 캐시된 것인지 아닌지 알 수 있습니다.


## 7.6 캐시 토폴로지

### 7.6.1 개인 전용 캐시 (private cache)

* 개인만을 위한 캐시로 한 명의 사용자가 자주 찾는 페이지를 담습니다.

* 웹 브라우저는 개인 전용 캐시를 내장합니다.

* 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용합니다. 

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/d3cf6fdf09b0303f0386177e8da1d319/7.3.png">


### 7.6.2 공용 프락시 캐시 (public cache)

* 공유된 캐시로 사용자 집단에게 자주 쓰이는 페이지를 담습니다.

* 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 프락시 서버입니다.

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/a34549a4dcc3263868ef1df7ecbb324e/7.4.png">

* 여러 사용자가 접근하므로, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있습니다.

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/6fc32786548e928131d8bbcaee550ec0/7.5.png">

### 7.6.3 프락시 캐시 계층들

* 캐시에 계층을 두어 작은 캐시에서 캐시 부적중이 발생했을 때, 더 큰 부모 캐시가 이를 처리하도록 하는 방식입니다.

* 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강렬한 캐시를 사용합니다.

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/5aab9872fead386c643f9a0f87d9b506/7.6.png">


### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

* 몇몇 네트워크 아키텍쳐는 단순한 캐시 계층 대신 복잡한 캐시망을 만듭니다.

* 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 아래 나열된 일을 할 수 있습니다.

  * URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택

  * URL에 근거하여 특정 부모 캐시를 동적으로 선택

  * 부모 캐시에게 가기전에, 캐시된 사본을 로컬에서 검색

  * 다른 캐시들이 그들의 캐시된 컨텐츠에 부분적으로 접근하도록 허용하되, 캐시를 통한 인터넷 트랜짓은 허용하지 않음

  > 인터넷 트랜짓: 트래픽이 다른 네트워크로 건너가는 것


## 7.7 캐시 처리 단계

* HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 7 단계로 이루어져 있다.

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/057ca53797ab9579b013b0cd17897a86/7.7.png">

### 7.7.1 단계 1) 요청 받기

* 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.

### 7.7.2 단계 2) 파싱

* 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.

* 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어준다.

### 7.7.3 단계 3) 검색

* 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아와 로컬에 저장한다.

* 캐시된 객체는 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지 등등의 몇몇 메타 데이터를 포함한다.

### 7.7.4 단계 4) 신선도 검사

* 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.

### 7.7.5 단계 5) 응답 생성

* 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.

### 7.7.6 단계 6) 발송

* 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.

### 7.7.7 단계 7) 로깅

* 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그를 남긴다.

### 7.7.8 캐시 처리 플로 차트
<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/24241c72ca55d9b9758116a16c21fac3/7.8.png">

## 7.8 사본을 신선(fresh)하게 유지하기

* 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 **문서 만료** 와 **서버 재검사** 라고 부릅니다.

### 7.8.1 문서 만료

* HTTP는 Cache-Control: max-age와 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줍니다.

```
HTTP/1.0 200 OK
Date: Wed, 03 Jul 2002, 19:18:03 GMT
Content-type: text/plain
Content-length: 67
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```

* 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사하고, 새 유효기간과 함께 신선한 사본을 얻어와야 합니다.

### 7.8.2 유효기간과 나이

* Cache-Control: max-age는 문서가 처음 생성된 이후부터 문서의 최대 나이(초 단위)를 정의합니다.

* Expires는 절대 유효기간을 명시합니다.

### 7.8.3 서버 재검사

* 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어보는 것을 서버 재검사라고 합니다.

* 재검사 결과 콘텐츠가 변경되었다면, 캐시는 새로운 사본을 가져와 저장 후 클라이언트에게 보내줍니다.

* 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신합니다.


### 7.8.4 조건부 메서드와 재검사

* HTTP는 캐시가 서버에게 '조건부 GET'이라는 요청을 보낼 수 있도록 해줍니다.

* 조건부 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것 입니다.

* 모든 조건부 헤더는 'If-'접두어로 시작합니다.

### 7.8.5 If-Modified-Since: 날짜 재검사

* 흔히 'IMS'요청으로 불리며 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 합니다.

* 문서가 주어진 날짜 이후로 변경되지 않았다면 서버는 작은 304 Not Modified 응답 메시지를 보내줍니다.

* 'IMS'헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작하며, 원 서버는 제공하는 문서에 최근 변경 일시를 붙입니다.

<img  width="547" src="https://gitlab.com/jibot/http_guide/uploads/8935bb5490360337568463e5b216f5bc/7.9.png">

### 7.8.6 If-None-Match: 엔터티 태그 재검사

* IMS 요청이 적절히 행해지기 어려운 상황이 몇 가지 존재합니다.

  1. 일정 시간 간격으로 문서가 변경되지만 실제로는 같은 데이터를 포함하는 경우

  2. 어떤 문서들의 변경이 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것인 경우 ( ex)철자나 주석의 변경 )

  3. 서버가 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별하지 못하는 경우

  4. 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버인 경우

* 퍼블리셔가 문서를 변경했을 때, 그는 문서의 엔티티 태그를 새로운 버젼으로 표현할 수 있습니다. ( ex) v.26인 문서 )

* 하나의 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있습니다.

```
If-None-Match: "v2.6"
If-None-Match: "v2.4","v2.5","v2.6"
If-None-March: "foobar","A34FAC0095","Profiles in Courage"
```

### 7.8.7 약한 검사기와 강한 검사기

* 약한 검사기는 어느 정도 콘텐츠 변경을 허용합니다.

* 약한 엔터티 태그는 대응하는 엔터티에 유의미한 변경이 있을 때만 변경됩니다.

* 서버는 'W/' 접두사로 약한 검사기를 구분합니다.

```
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

* 강한 검사기는 콘텐츠가 바뀔때 마다 바뀝니다.

* 강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 합니다.

## 7.9 캐시 제어

* HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러가지 방법을 정의합니다.

  1. Cache-Control: no-store 헤더를 응답에 첨부

  2. Cache-Control: no-cache 헤더를 응답에 첨부

  3. Cache-Control: must-revalidate 헤더를 응답에 첨부

  4. Cache-Control: max-age 헤더를 응답에 첨부

  5. Expires 날짜 헤더를 응답에 첨부

  6. 아무 만료 정보도 주지 않고, 캐시 스스로 체험적인(휴리스틱) 방법으로 결정

### 7.9.1 no-cache와 no-store 응답 헤더

* no-cache와 no-store 응답 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막습니다.

* **no-store** 가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지합니다.

* **no-cache** 가 표시된 응답은 로컬 캐시 저장소에 저장될 수 있지만, 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없습니다.

* Pragma: no-cache 헤더는 HTTP/1.0+ 와의 하위호환성을 위해 HTTP/1.1에 포함되어 있지만, 일반적으로는 Cache-Control: no-cache를 사용해야 합니다.

### 7.9.2 must-revalidate 응답 헤더

* 캐시는 성능을 개선하기 위해 만료된 객체를 제공하도록 설정될 수 있습니다.

* 캐시가 만료 정보를 업격하게 따르길 원한다면, 원 서버는 must-revalidate 응답 헤더를 붙일 수 있습니다.

* **must-revalidate** 가 표시된 응답은 캐시가 원 서버와의 최초의 재검사 없이는 신선하지 않은 사본을 제공해서는 안됨을 의미합니다.

* 캐시가 must-revalidate 신선도 검사를 시도했을 때, 원 서버가 사용할 수 없는 상태라면 캐시는 반드시 504 Gateway Timeout error를 반환해야 합니다.

### 7.9.3 max-age 응답 헤더

* **max-age** 가 표시된 응답은 신선하다고 간주되었떤 문서가 서버로부터 온 이후로 흐른 시간(초)를 나태닙니다.

* 서버는 maximum aging을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있습니다.

### 7.9.4 Expires 응답 헤더

* **expires** 는 deprecated 되었으며 초 단위의 시간 대신 실제 만료 날짜를 명시합니다.

### 7.9.5 휴리스틱 만료

* LM 알고리즘에 따르면, 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면 좀 더 오래 보관하고, 최근에 변경되었다면 짧은 기간만 캐시합니다.

### 7.9.6 클라이언트 신선도 제약

* Cache-Control 요청 지시어 헤더를 통해 클라이언트는 만료 제약을 엄격하게 하거나 느슨하게 할 수 있습니다.

## 7.10 캐시 제어 설정

* 웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공합니다.

* 구체적인 상세에 대해서는 사용하고 있는 웹 서버의 문서를 참조하여야 합니다.  

## 7.11 자세한 알고리즘

* HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 알고리즘을 제공합니다.

* 캐시 만료 공식의 적나라한 세부사항에 관심이 없으므로 이 절은 건너 뛰겠습니다.

## 7.12 캐시와 광고

* 캐시는 사용자를 도와 더 좋은 경험을 제공하고, 네트워크 사업자들이 트래픽을 줄일 수 있도록 도와줍니다.

### 7.12.1 광고회사의 딜레마

* 캐시는 호화로운 기사나 광고를 사용자의 스크린에 빠르면서도 더 잘 보여줄 수 있다는 점에서 콘텐츠 제공자들에게 매력적입니다.

* 그러나 캐시는 원서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다는 점에서 딜레마가 존재합니다.

### 7.12.2 퍼블리셔의 응답

* 광고회사는 캐시가 광고 시청수를 가로채지 못하도록 캐시 무력화 기법을 사용합니다.

  * 광고를 CGI 게이트 웨이를 통해 제공하기

  * 매 접근마다 광고 URL을 고쳐 쓰기

  * 모든 접근에 대해 원 서버와 재검사하도록 캐시 설정


### 7.12.3 로그 마이그레이션

* 서버로 요청이 가지 않도록 하여 트랜잭션을 빠르게 하기 위하여 캐시가 모든 적중의 로그를 유지할 수 있습니다.

* 캐시는 이 로그를 서버에게 나누어 줄 수 있을 것입니다.

* 적중 로그의 크기 문제, 표준화 문제, 인증 및 프라이버시 등의 이슈가 존재합니다.

* 통합된 캐싱과 로깅을 위한 글로벌 솔루션의 개발을 시도하는 몇몇 사업이 런칭된 상태입니다.

### 7.12.4 적중 측정과 사용량 제한

* RFC 2227 프로토콜은 HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라고 하는 새 헤더 하나를 추가하는 더 간단한 방법을 정의합니다.

* 이 방법은 서버가 캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로부터 받습니다.

* 서버는 캐시가 서버에게 보고해야 하기 전까지 문서를 제공할 수 있는 횟수나 소모할 수 있는 처리시간을 제어할 수 있습니다. 이를 사용량 제한이라고 부릅니다.

* 사용량 제한은 캐시가 원 서버에게 보고하기 전에 캐시된 리소스가 얼마나 많이 사용될 수 있는지 서버가 제어할 수 있게 해줍니다.
