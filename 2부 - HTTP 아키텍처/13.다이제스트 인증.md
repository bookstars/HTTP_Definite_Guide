# 13. 다이제스트 인증

이 장에서는 보안 트랜잭션을 위해 기본 인증과 호환되는, 더 안전한 대체재로 개발된 다이제스트 인증에 대해서 알아봅니다.

## 13.1 다이제스트 인증의 개선점

다이제스트 인증은 기본 인증의 결함을 수정한 또 다른 HTTP 인증 프로토콜입니다. 그 특징은 다음과 같습니다 .

- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.

- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.

- 메시지 내용 위조를 막는 것도 가능하다.

- 몇몇 잘 알려진 형태의 공격을 막는다.

다이제스트 인증이 가장 안전한 프로토콜은 아닙니다. 안전한 HTTP 트랜잭션을 위한 요구사항들에는 TLS와 HTTPS가 더 적합한 프로토콜입니다. 그러나 기본 인증을 대체하기 위해 설계된 다이제스트 인증은 기본 인증보다 훨씬 강력합니다.

### 13.1.1 비밀번호 안전하게 지키기 위해 요약 사용하기

다이제스트 인증은 비밀번호를 절대로 네트워크를 통해 평문으로 보내지 않기 위해, 클라이언트가 비밀번호를 비가역적으로 뒤섞은 지문(fingerprint) 혹은 요약(digest)를 보냅니다. 클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사합니다. 인증 동작은 다음과 같습니다.

1. 클라이언트가 보호된 문서를 요구

2. 서버는 클라이언트에게 비밀번호를 요구

3. 클라이언트는 비밀번호의 요약을 전달

4. 서버는 클라이언트가 제공한 비밀번호 요약과 내부적으로 계산한 비밀번호 요약을 비교

5. 문서 제공

### 13.1.2 단방향 요약

요약은 정보 본문의 압축입니다. 요약은 단방향 함수로 동작하고, 일반적으로 입력가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환합니다.

대표적인 MD5 요약 함수는 임의의 바이트 배열을 128비트로 요약합니다. 이는 종종 32글자의 16진수 문자로 표현되며, 각 문자는 4비트 값을 의미합니다.  

요약 함수는 보통 암호 체크섬으로 불리며 단방향 해시 함수이거나 지문(fingerprint) 함수 입니다.

### 13.1.3 재전송 방지를 위한 nonce 사용

단방향 요약은 비밀번호를 그대로 전송하지 않게 해줍니다. 그러나 비밀 번호를 모른다고 해도 요약을 가로채서 서버로 몇 번이고 재전송할 수 있기 때문에 요약은 비밀번호 자체와 다름이 없습니다.

이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 nonce라고 불리는 특별하고, 자주 변경되는 (대략 1밀리초나 인증할 때마다) 증표를 건네줍니다. 저장된 비밀번호 요약은 특정 nonce값에 대해서만 유효합니다.

### 13.1.4 다이제스트 인증 핸드 셰이크

다이제스트 인증 프로토콜 헤더에 몇몇 새 옵션과, 선택적 헤더인 Authorization-Info가 추가되었습니다. 핸드 셰이크 과정은 다음과 같습니다.

1. 서버가 nonce를 생성

2. 서버의 인증 요구 (WWW-Authenticate)

3. 클라이언트가 알고리즘을 선택하고 요약을 계산

4. 클라이언트가 응답 요약을 보냄, 클라이언트가 서버를 인증하기 원한다면 클라이언트 nonce를 보냄

5. 서버가 요약을 검증

6. 서버가 다음번 nonce를 보냄

이를 기본 인증과 비교하여 보면 다음 그림과 같습니다.

<img  width="720" src="https://gitlab.com/jibot/http_guide/uploads/2d251c2a3c01af62562567311008c73b/스크린샷_2019-04-14_오후_5.05.41.png">

## 13.2 요약 계산

데이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 nonce 값을 조합한 단방향 요약입니다.

### 13.2.1 요약 알고리즘 입력 되이터

- 단방향 해시함수 H(d), 요약함수 KD(s,d)
  - s는 비밀, d는 데이터를 의미합니다.

- 보안정보를 담고 있는 데이터 덩어리 (A1)

- 비밀이 아닌 속성을 담고 있는 데이터 덩어리 (A2)

A1, A2 두 조각의 데이터는 요약을 생서하기 위해 H와 KD에 의해 처리 됩니다.

### 13.2.2 H(d)와 KD(s,d) 알고리즘

다이제스트 인증은 여러 가지 요약 알고리즘을 지원하며 MD5가 기본값 입니다. H 함수는 데이터의 MD5를 계산하고, KD 요약 함수는 콜론으로 연결된 비밀 데이터와 일반 데이터의 MD5를 계산합니다.

### 13.2.3 보안 데이터 (A1)

사용자 이름, 비밀번호, 보호 영역, nonce와 같은 비밀 보호 정보르 이루어져 있습니다. 알고리즘에 따른 A1의 정의는 다음과 같습니다.

<img src="https://gitlab.com/jibot/http_guide/uploads/d83fcdf013338dfc44eb6a621f38fe4f/스크린샷_2019-04-14_오후_5.12.39.png">

### 13.2.4 메시지 관련 데이터 (A2)

URL, 요청 메서드와 같은 메시지 자체의 정보를 나타냅니다. 선택된 보호 수준(quality of protection, qop)에 따라 다음과 같이 사용합니다.

<img src="https://gitlab.com/jibot/http_guide/uploads/5f458765254e6f99d474a27d118c3e13/스크린샷_2019-04-14_오후_5.15.05.png">

### 13.2.5 요약 알고리즘 전반

이를 조합하여 나타내면 다음과 같습니다.

<img src="https://gitlab.com/jibot/http_guide/uploads/e8e113c3700cd69dd548a800ca0d8bf8/스크린샷_2019-04-14_오후_5.16.53.png">

### 13.2.6 다이제스트 인증 세션

어떤 보호 공간을 위한 WWW-Authenticate 인증 요구에 대한 클라이언트 응답은 그 보호 공간에 대한 인증 세션을 시작하게 합니다. 인증 세션은 클라이언트가 보호 공간의 다른 서버로 부터 또 다른 WWW-Authenticate 인증 요구를 받을 때 까지 지속됩니다. 클라이언트는 Authorization 헤더를 만들기 위해 사용될 인증 세션과 연관된 값들을 기억해야 합니다.

### 13.2.7 사전 인가

일반적인 인증은 요청/인증요구 사이클을 필요로 합니다. 만약 클라이언트가 다음 난스를 미리 알고 있어서, 서버가 요청하기 전 올바른 Authorization 헤더를 생성할 수 있다면, 이 사이클은 생략 가능합니다.

<img src="https://gitlab.com/jibot/http_guide/uploads/3e6d2ee18cc5e56ee8eb97bfa92b11b0/스크린샷_2019-04-14_오후_5.21.14.png">

클라이언트가 새 WWW-Authenticate 인증 요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법은 다음과 같습니다.

1. 서버가 다음 난스를 Authenticate-Info 성공 헤더에 담아서 미리 보낸다.

  - Authenticate-Info: nextnouce="<난스 값>"

2. 서버가 짧은 기간 동안 같은 난스를 재사용하는 것을 허용한다.

3. 서버와 클라이언트가 동기화되어있고, 예측 가능한 난스 생성 알고리즘을 사용한다.

### 13.2.8 난스 선택

난스의 내용은 불투명 하고 구현 의존적입니다. RFC 2617은 다음과 같은 가상의 난스 공식을 제안했습니다.

```
BASE64(타임스탬프 H(타임스탬프":" ETag ":" 개인 키))
```

### 13.2.9 상호 인증

RFC 2617은 클라이언트가 서버를 인증 할 수 있도록 다이제스트 인증을 확장했습니다. 이는 클라이언트 난스(c nonce)값을 제공함으로써 가능해집니다. 이후 서버는 이 요약을 Authenticate-Info 헤더를 통해 클라이언트에게 전달합니다. 요청과 응담을 위한 A2 계산 방법은 다음과 같습니다.

- 알고리즘 별 A2 요청 요약 정의

<img src="https://gitlab.com/jibot/http_guide/uploads/2068f1b7b8f62e81d59f031b490e571b/스크린샷_2019-04-14_오후_5.28.43.png">

- 알고리즘 별 A2 응답 요약 정의

<img src="https://gitlab.com/jibot/http_guide/uploads/1904f55173d2df2dd8b9728e8c79f46f/스크린샷_2019-04-14_오후_5.29.03.png">


## 13.3 보호 수준 (qop) 향상

qop 필드는 요약 헤더의 세 가지 헤더 WWW-Authenticate, Authorization, Authentication-Info에 모두 존재할 수 있습니다. qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해줍니다. RFC 2617은 기본적으로 두 가지 초기 보호 수준 값을 정의합니다. 하나는 인증을 의미하는 auth이고, 다른 하나는 인증 및 메시지 무결성 보호를 의미하는 auth-int 입니다.

### 13.3.1 메시지 무결성 보호

무결성 보호가 적용되었을 때 (qop="auth-int") 계산되는 엔터티 본문은 메시지 본문의 해시가 아닌 엔터티 본문의 해시입니다.

### 13.3.2 다이제스트 인증 헤더

기본, 디이제스트 인증 프로토콜 모두 WWW-Authenticate 헤더에 담겨 전될되는 인증 요구와, Authorization 헤더에 담겨 전달되는 인가 응답을 포함합니다. 다이제스트 인증은 여기에 선택적인 Authentication-Info 헤더를 추가했습니다. 이 헤더는 3단계 핸드셰이크를 완성하고 다음번 사용할 난스를 전달하기 위해 인증 성공 후, 전송됩니다.

<img src="https://gitlab.com/jibot/http_guide/uploads/9a617f0de9ce41785bcfe08a25f71693/스크린샷_2019-04-14_오후_5.42.04.png">

## 13.4 실제 상황에 대한 고려

### 13.4.1 다중 인증 요구

서버는 한 리소스에 대해 여러 인증을 요구할 수 있습니다. 다중 인증 요구에 직면했을 때, 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 합니다.


### 13.4.2 오류 처리

다이제스트 인증에서 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져있는 경우 알맞은 응답은 400 Bad Request 입니다.

요청의 요약이 반복적으로 실패되었다면 공격자가 비밀번호 추측을 시도하고 있음을 의미합니다.

### 13.4.3 보호 공간

영역 값은 접근한 서버 루트 URL과 결합되어, 보호공간을 정의합니다.

- 기본 인증에서 클라이언트는 요청 URI와 그 하위의 모든 경로는 같은 보호 공간에 있는 것으로 가정합니다. 클라이언트는 서버로부터 또 다른 인증 요구를 기다리지 않고, 미리 리소스에 대한 인가를 받을 수 있습니다.

- 다이제스트 인증에서 인증요구의 WWW-Authenticate: domain 필드는 보호 공간을 보다 엄밀하게 정의합니다. 이 domain 목록의 모든 URI와 하위의 URI는 같은 보호 공간에 있는 것으로 가정합니다. 이 필드가 없거나 비어있다면, 인증을 요구하는 서버의 모든 URI는 보호공간에 있습니다.

### 13.4.4 URI 다시 쓰기

다음의 경우, 프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 합니다.

- 호스트 명은 정규화 되거나 IP주소로 대체될 수 있다.

- 문자들은 "%" escape 형식으로 대체될 수 있다.

- 특정 원 서버로부터 가져오는 리소스에 영향을 주지 않는, 타입에 대한 추가 속성이 URI의 끝에 붙거나 중간에 삽입될 수 있다.

프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로 다이제스트 인증은 이러한 변경에 의해 실패할 수 있습니다.

### 13.4.5 캐시

어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음의 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안됩니다.

- 원 서버의 응답이 "must-revalidate" Cache-Control 지시자를 포함한 경우, 캐시는 그 요청의 헤더를 이용해 재검사를 수행하고 그 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용할 것이다.

- 원 서버의 응답이 "public" Cache-Control 지시자를 포함한 경우, 응답 엔터티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환될 수 있다.

## 13.5 보안에 대한 고려 사항

### 13.5.1 헤더 부당 변경

다이제스트 인증은 쉽게 조작할 수 없는 인증 제도를 제공하는 것에 초점을 맞추고 있으나, 반드시 그 보호를 데이터까지 확장하는 것은 아닙니다. 보호 수준에 대한 정보는 WWW-Authenticate와 Authorization에만 담겨 있습니다.

### 13.5.2 재전송 공격

재전송 공격을 완전히 피하는 방법은 매 트랜잭션마다 유일한 난스 값을 사용하는 것 입니다. 이 계산이 서버에 부하를 가중시킬 수도 있으나 사소한 수준입니다.

### 13.5.3 다중 인증 메커니즘

서버가 다중 인증 제도를 지원할 때, WWW-Authenticate 헤더를 통해 선택지를 제공할 것 입니다. 클라이언트에게 가장 강력한 인증 메커니즘을 선택해야할 의무가 있는 것은 아니기 때문에 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용할 수도 있습니다. 그러나 이런 접근은 사내 네트워크 같은 오직 모든 클라이언트가 선택된 강력한 인증제도를 지원할 수 있다고 알려진 경우에만 실현 가능합니다.

### 13.5.4 사전(dictionary) 공격

전형적인 비밀번호 추측 공격입니다. 상대적으로 단순한 비밀번호와 단순한 난스를 사용하고 있다면 추측이 쉬울 수 있습니다. 크래킹하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하거나 괜찮은 비밀번호 만료 정책을 사용할 수 있습니다.

### 13.5.5 악의적인 프락시와 중간자 공격

프락시들을 이용하는 확장(플러그 인 등)을 작성하여 트래픽을 가로채 수정하는 것은 가능한 일입니다. 이런 공격을 방어할 유일한 실패하지 않는 방법은 SSL을 사용하는 것 입니다.

### 13.5.6 선택 평문 공격

다이제스트 인증을 사용하는 클라이언트는 응답을 생성하기 위해 서버가 제공한 난스를 사용합니다. 그러나 보안이 허술하거나 악의적인 프락시가 있다면 클라이언트가 응답 계산을 하기 위한 난스를 제공할 수 있습니다. 이는 응답의 암호 해독을 쉽게 하는 선택 평문 공격을 야기합니다.

이를 위해 서버에서 제공된 난스 대신 선택적인 c 난스 지시자를 사용하여 응답을 생성할 수 있도록 설정할 수 있습니다.

### 13.5.7 비밀번호 저장

다이제스트 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 즉각 공격자에게 노출됩니다. 암호 해독과정은 필요 없습니다. 이를 해결하기 위한 방법은 다음과 같습니다.

- 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 가정하고 최대한 안전하게 보호

- 영역 이름이 유일함을 보장하며, 파일이 유출되더라도 피해를 특정 영역으로 국소화

다이제스트 인증이 기본 인증에 비해 훨씬 안전한 해결책을 제공함에도 불구하고, 여전히 콘텐츠 자체에 대한 보안 측면에서는 어떠한 보호도 제공하지 못합니다.

진정한 보안 트랜잭션은 다음 장에서 다룰 SSL을 통해서만 가능합니다.
