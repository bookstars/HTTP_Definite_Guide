# 기본 인증

이번 장에서는 HTTP 인증과 그것의 기본이 되는 기본 인증을 알아볼 것입니다.

## 12.1 인증

-   **인증**이란 사용자가 누구인지 증명하는 것입니다.

### 12.1.1 HTTP의 인증요구/응답 프레임 워크

-   HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공 합니다.

    <img width="522" alt="스크린샷 2019-04-20 오후 7 00 02" src="https://user-images.githubusercontent.com/44794974/56455847-f51fdf00-639e-11e9-8812-0a469831d545.png">

-   웹 에플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답할 수 있습니다.

-   사용자가 다시 요청을 보낼 때는 인증 정보(사용자 이름과 비밀번호)를 첨부해야 합니다.

### 12.1.2 인증 프로토콜과 헤더

-   HTTP는 필요에 따라 고쳐 쓸 수 있는 **제어 헤더**를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임 워크를 제공합니다.

-   HTTP에는 **기본 인증**과 **다이제스트** 인증이라는 두 가지 공식적인 인증 프로토콜이 있습니다.(이 장에서는 기본 인증을 설명합니다. 13장, 다이제스트)

-   다음 표와 그림을 통해 인증 방법에 대해 알아보겠습니다.

    ![스크린샷 2019-04-21 오전 12 59 31](https://user-images.githubusercontent.com/44794974/56459620-fff36780-63d0-11e9-9501-8bba38918ec9.png)
    ![스크린샷 2019-04-21 오전 12 59 43](https://user-images.githubusercontent.com/44794974/56459623-041f8500-63d1-11e9-9d6b-69de79c4ebdc.png)
    ![스크린샷 2019-04-21 오전 12 59 49](https://user-images.githubusercontent.com/44794974/56459627-0b469300-63d1-11e9-85c6-c494fdd8cfa1.png)

    -   (a) 사용자가 서버에게 인증이 필요한 GET 요청을 보냅니다.
    -   (b) 서버는 사용자에게 **401 Unauthorized** 응답으로 인증 요구를 보내고, 함께 **WWW-Authenticate** 헤데를 기술해서 어디서 어떻게 인증할지 설명합니다.
    -   (c) 사용자는 서버 인증을 위해, 인코딩된 비밀번호와 그 외 인증 파라미터들을 **Authorization** 헤더에 담아서 요청을 다시 보냅니다.
    -   (d) 서버는 정상적인 상태 코드(ex, 200 OK)를 반환하며, 추가적인 인증 알고리즘에 대한 정보를 Authentication-info 헤더에 기술할 수도 있습니다.

### 12.1.3 보안 영역

-   HTTP가 어떻게 각 리소스마다 다른 **접근 조건**을 다루는지 알아보겠습니다.

-   (b) 단계에서 서버가 클라이언트로 인증요구를 할 떄, realm 지시자가 기술되어 있는 WWW-Authenticate 헤더를 볼 수 있습니다.

-   웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눕니다. 보안 영역은 저마다 다른 사용자 권한을 요구합니다.

## 12.2 기본 인증

-   기본 인증은 가장 잘 알려진 HTTP 인증 규약입니다. 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어 있습니다.

-   기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있습니다.

-   서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 응답하여 인증요구를 시작합니다.

-   인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는, 사용자에게 계정과 비밀번호를 입력할 수 있는 대화상자를 엽니다.

-   브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화해서 서버로 다시 보냅니다.

### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩

-   HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, **base-64** 인코딩 메서드를 사용해 인코딩 합니다.

-   **base-64** 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환합니다. 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택 됩니다.

    <img width="526" alt="스크린샷 2019-04-22 오전 12 18 28" src="https://user-images.githubusercontent.com/44794974/56472005-42ca4380-6494-11e9-892d-ee7e1157f673.png">

### 12.2.3 프락시 인증

-   중개 프락시 서버를 통해 인증할 수도 있습니다.

-   프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋습니다.

-   프락시 인증은 다음과 같이 웹 서버의 인증과 헤더와 상태 코드만 다르고 절차는 같습니다.

    <img width="583" alt="스크린샷 2019-04-22 오전 12 24 40" src="https://user-images.githubusercontent.com/44794974/56472073-1662f700-6495-11e9-910f-6c4047def251.png">

### 12.3 기본 인증의 보안 결함

-   기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용 합니다.

    1. 기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송합니다.

        - base-64 인코딩은 사용자 이름과 비밀번호를 알아내기 어렵게 인코딩 합니다.

        - 하지만, base-64로 인코딩된 사용자 이름과 비밀번호는 인코딩 절차를 반대로 수행해서 어렵지 않게 디코딩 할 수 있습니다.(base-64로 인코딩된 비밀번호는 사실상 '그대로' 보내는 것과 다름없습니다.)

        - 이를 방지하기 위해, 모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는게 좋습니다.

    2. 기본인증은 사용자의 비밀번호와, 이름을 가로채 서버에 재전송 하여 인증에 성공할 수 있는 공격에 대해 어떠한 대책이 없습니다.

    3. 메세지의 인증 헤더를 건드리지 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않습니다.

    4. 기본 인증은 가짜 서버의 위장에 취약합니다.

-   기본 인증은 일반적인 환경에서 개인화나 접근을 제어하는데 편리하며, 다른 사람들이 보지 않기를 원하기는 하지만, 보더라도 치명적이지 않는 경우에는 여전히 유용합니다.

-   사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송(ex, SSL)과 함께 연계해서 사용할 수 있습니다.